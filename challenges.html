<p>Through the course of implementing the distributed Kalman filter, there were several challenges and drawbacks that were observed for each of the implementations, spanning diffusion based, optimization and DICI-OR based methods. While some implementations performed well in some instances, they performed worse in the other. 
<br>
<br>

With Diffusion EKF, the fundamental problem of having to maintain the full error covariance matrix as well as state estimate vectors at all nodes severely limit its scalability. We were also observing instances where the position estimates would push towards converging with each other. The time sync errors were also sub-optimal when the algorithm was implemented with the reduced matrices. We noticed that the diffusion update mechanism, where each of a nodeâ€™s neighbor updates its estimates based on the weighted average of the estimates from its neighbors was causing error in the position and time synchronization tracking. While removing this step in the filtering process did help with the accuracy of the results, they were still not up to par with the other algorithms in certain network configurations. 
<br>
<br>

There were implementation challenges while looking at DICI-OR implementation as well. The paper that presents the idea which requires concepts of message passing (in the information domain Z) wherein subsystems are expected to pass messages between each other to further refine the estimates. Since we have limited node count, our problem does not explicitly require the message passing scheme. The scheme however, would work better if the number of nodes in test are large and corroboration of state estimates by more neighboring/non-neighboring nodes would help improve the estimates of both the location as well as the time synchronization. We thus shifted away from converting to and from the Z domain and rather chose to stay in the Kalman Filter domain. This was essentially the middle ground that gave us good performance results with reduced matrices per neighborhood size. 
<br>
<br>

Once we decided the adapt the implementation to remain in the Kalman filter domain, the other observation was that the localization was accurate but the time synchronization was still not up to the mark. We would observe the nodes connected to the reference node having god time synchronization while the nodes that were not connected to the reference node would return erroneous results. We narrowed it down to how the reference node is set and how the same is used to calculate the offset and bias. Through some tests, it was established that if one node is not in the neighborhood of the reference node, then that node would have its estimates for offset and bias on the inaccurate side. 
<br>
<br>

The simplest fix for this was to implement some measurement publication mechanism. Taking one example, it we consider the same set of global nodes = [1 2 3 4 5 6 7 8], and if we consider the split of the subsystems to be S1 = [1 2 3 4 5] and S2 = [4 5 6 7 8], then it is seen that nodes 6, 7 and 8 return errors in time synchronization. This is because they are not one hop neighbors to the reference node 1. A measurement publish mechanism where the nodes share the clock and bias information (sender is always the one that is reference node or the neighbors of the reference node) helped deal with this issue. While this solution fixes the issue, the new requirement that it places is that the reference node still needs to be at least a two-hop neighbor of all the nodes in the network under test in its current form.   
<br>
<br>

This problem can be fixed by minor code level changes for use in larger networks with higher number of nodes. In the current network with 8 UWB nodes, the reference node being a 2-hop neighbor for all nodes is a given as long as we do not break down the subsystems to include less than 3 nodes in one neighborhood.</p>


